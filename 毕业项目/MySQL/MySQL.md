# MySQL

## 事务

### MySQL事务

- 事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务。
- 一个完整的业务需要批量的DML（insert、update、delete）语句共同联合完成。
- 事务只和 DML 语句有关，或者说 DML 语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML 语句的个数不同。

### 四大特征（ACID）

- 原子性（A）：事务是最小单位，不可再分
- 一致性（C）：事务要求所有的 DML 语句操作的时候，必须保证同时成功或者同时失败
- 隔离性（I）：事务 A 和事务 B 之间具有隔离性
- 持久性（D）：事务的保证，事务终结的标志（内存的数据持久到硬盘文件中）

### 锁

- 表级锁

	- 意向锁：表明事务稍后要进行哪种类型的锁定

		- 共享意向锁（IS）：打算在某些行上设置共享锁
		- 排他意向锁（IX）：打算对某些行设置排他锁
		- Insert意向锁：Insert 操作设置的间隙锁

	- 其他

		- 自增锁（AUTO-IN）
		- LOCK TABLE/DDL

- 行级锁（InnoDB）

	- 记录锁（Record）：始终锁定索引记录，注意隐藏的聚簇索引；
	- 间隙锁（Gap）
	- 临键锁（Next-Key）：记录锁+间隙锁的组合；可 ”锁定“ 表中不存在记录
	- 谓词锁（Predicat）：空间索引

- 死锁

	- 阻塞与互相等待
	- 增删改、锁定读
	- 死锁检测与自动回滚
	- 锁粒度与程序设计

### 事务隔离级别

- 读未提交：READ UNCOMMITTED

	- 定义

		- 一个事务写数据时，只允许其他事务对这行数据进行读，所以会出现脏读，事务 T1 读取 T2 未提交的数据

	- 特点

		- 很少使用
		- 不能保证一致性
		- 脏读（Dirty read）：使用到从未被确认的数据（例如：早期版本、回滚）

	- 锁

		- 以非锁定方式执行
		- 可能的问题：脏读、幻读、不可重复读

- 读已提交：READ COMMITTED

	- 定义

		- 读取数据的事务允许其他事务进行操作，避免了脏读，但是会出现不可重复读，事务 T1 读取数据，T2 紧接着更新数据并提交数据，事务 T1 再次读取数据的时候，和第一次读的不一样。即虚读

	- 特点

		- 每次查询都会设置和读取自己的新快照
		- 仅支持基于行的 bin-log
		- UPDATE优化：半一致读（semi-consistent read）
		- 不可重复读：不加锁的情况下，其他事务 UPDATE 或 DELETE 会对查找结果有影响
		- 幻读（Phantom）：加锁后，不锁定间隙，其他事务可以 INSERT。

	- 锁

		- 锁定索引记录，而不锁定记录之间的间隙
		- 可能的问题：幻读、不可重复读

- 可重复读：REPEATABLE READ

	- 定义

		- 读事务会禁止所有的写事务，但是允许读事务，避免了不可重复读和脏读，但是会出现幻读，即第二次查询数据时包含第一次查询中未出现的数据

	- 特点

		- InnoDB的默认隔离级别
		- 使用事务第一次读取时创建的快照
		- 多版本技术

	- 锁

		- 使用唯一索引的唯一查询条件时，只锁定产找的索引记录，不锁定间隙
		- 其他查询条件，会锁定扫描到的索引范围，通过间隙锁或临键锁来阻止其他会话在这个范围中插入值。
		- 可能的问题：InnoDB不能保证没有幻读，需要加锁

- 可串行化：SERIALIZABLE

	- 特点

		- 最严格的级别
		- 事务串行执行
		- 资源消耗最大

	- 问题

		- 脏读（Dirty read）：使用到从未被确认的数据（例如：早期版本、回滚）
		- 不可重复读：不加锁的情况下，其他事务 UPDATE 或 DELETE 会对结果集有影响
		- 幻读（Phantom）：加锁之后，相同的查询语句，在不同的时间点执行时，产生不同的结果集

### 日志文件

- undo log：撤销日志

	- 特点

		- 保证事务的原子性
		- 用处：事务回滚，一致性读，崩溃恢复
		- 记录事务回滚时所需的撤销操作
		- 一条 INSERT 语句，对应一条 DELETE 的 undo log
		- 每个 UPDATE 语句，对应一条相反 UPDATE 的 undo log

	- 保存位置

		- system tablespace(MySQL 5.7 默认)
		- undo tablespaces(MySQL 8.0 默认)

- redo log：重做日志

	- 特点

		- 确保事务的持久性，防止事务提交后数据为刷新到磁盘就掉电或崩溃
		- 事务执行过程中写入 redo log，记录事务对数据做了哪些修改。
		- 提升性能：WAL（Write-Ahead Logging）技术，先写日志，再写磁盘
		- 日志文件：ib_logfile0，ib_logfile1
		- 日志缓冲：innodb_log_buffer_size
		- 强制：fsync()

### MVCC：多版本并发控制

- 特点

	- 使 InnoDB 支持一致性读：READ COMMITTED 和 REPEATABLE READ。
	- 让查询不被阻塞、无需等待被其他事务特有的锁，这种技术手段可以增加并发性能。
	- InnoDB 保留被修改行的旧版本
	- 查询正在被其他事务更新的数据时，会读取更新之前的版本。
	- 每行数据都存在一个版本号，每次更新时都更新该版本
	- 这种技术在数据库领域的使用并不普遍。某些数据库，以及某些 MySQL 存储引擎都不支持。

- 实现机制

	- 隐藏列
	- 事务链表，保存还未提交的事务，事务提交则会从链表中摘除
	- ReadView：每个 SQL 一个，包括 rw_trx_ids，low_limit_id，up_limit_id，low_limit_no 等
	- 回滚段：通过 undo log 动态构建旧版本数据

## 集群

### 单机 MySQL 面临的问题

- 容量有限，难以扩容
- 读写压力，QPS 过大，特别是分析类需求会影响到业务事务
- 可用性不足，宕机问题

## MySQL 主从复制

### 原理

- master 服务器将数据的改变记录二进制 binlog 日志，当 master 上的数据发生改变时，则将其改变写入二进制日志中；
- slave 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变，则开始一个 I/OThread 和 SQLThread 将进入睡眠状态，等待下一次被唤醒。
- 同时主节点为每个 I/O 线程启动一个 dump 线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动 SQL 线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后 I/OThread 和 SQLThread 将进入睡眠状态，等待下一次被唤醒。

### 步骤

- 1.主库 db 的更新事件（update、insert、delete）被写到 binlog
- 2.从库发起连接，连接到主库
- 3.此时主库创建一个 binlog dump thread 线程，把 binlog 的内容发送到从库
- 4.从库启动之后，创建一个 I/O 线程，读取主库传过来的 binlog 内容并写入到 relay log。
- 5.还会创建一个 SQL 线程，从 relay log 里面读取内容，从 Exec_Master_Log_Pos 位置开始执行读取到的更新事件，将更新内容写入到 slave 的 db。

### binlog 格式

- Statement

	- 记录每一条修改数据的 SQL 语句（批量的不是单条 SQL 语句，而是批量修改的 SQL 语句事件）所以大大减少了 binlog 日志量，节约磁盘 IO，提高性能。但是 Statement 对一些特殊功能的复制效果不是很好。由于 row 是基于每一行的变化来记录的，所以不会出现类似问题。

- Row

	- Row 格式会记录每行记录修改的记录，这样可能会产生大量的日志内容，比如一条 update 语句修改了 100 条记录，那么这 100 条记录的修改都会被记录在 binlog 日志中，这样造成 binlog 日志量会很大，这种日志格式会占用大量的系统资源。

- Mixed

	- 实际上就是前两种模式的结合。在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 Statement 和 Row 之间选择一种。

### 四种方式

- 异步复制（Asynchronous replication）

	- 逻辑上

		- MySQL 默认的复制既是异步的，主库在执行完客户端提交的事务后会立即将结果返给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主库如果 crash 掉了，此时主库上已经提交的事务可能并没有传到从库上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。

	- 技术上

		- 主库将事务 Binlog 事件写入到 Binlog 文件中，此时主库只会通知一下 Dump 线程发送这些新的 Binlog，然后主库就会继续处理提交操作，而此时不会保证这些 Binlog 传到任何一个从库节点上。

	- 步骤

		- 1. 在 Slave 服务器上执行 start slave 命令开启主从复制开关，开始进行主从复制。
		- 2.此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的指定位置(日志文件名和位置就是在配置主从复制服务时执行change master命令指定的)之后开始发送binlog日志内容
		- 3.Master服务器接收到来自Slave服务器的IO线程的请求后，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在Master服务器端记录的IO线程。返回的信息中除了binlog中的下一个指定更新位置。
		- 4.当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到Slave端自身的Relay Log(即中继日志)文件(Mysql-relay-bin.xxx)的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容
		- 5.Slave服务器端的SQL线程会实时检测本地Relay Log 中IO线程新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点

- 全同步复制（Fully synchronous replication）

	- 逻辑上

		- 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。

	- 技术上

		- 当主库提交事务之后，所有的从库节点必须收到、APPLY并且提交这些事务，然后主库线程才能继续做后续操作。但缺点是，主库完成一个事务的时间会被拉长，性能降低。

- 半同步复制(Semisynchronous replication)

	- 逻辑上

		- 是介于全同步复制与全异步复制之间的一种，主库只需要等待至少一个从库节点收到并且 Flush Binlog 到 Relay Log 文件即可，主库不需要等待所有从库给主库反馈。同时，这里只是一个收到的反馈，而不是已经完全完成并且提交的反馈，如此，节省了很多时间。

	- 技术上

		- 介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。

## 读写分离

### 基本特性

- 原理

	- 在主服务器上修改，数据会同步到从服务器，从服务器只能提供读写数据，不能写入，实现备份的同时实现了数据库性能的优化，以及提升了服务器安全。

- 为什么需要读写分离

	- 数据库的“写”操作是比较耗时的，但是数据库的“读”很快。

- 什么时候用

	- 数据库不一定要读写分离，如果程序使用数据库较多，而更新少，查询多的情况下会考虑使用，利用数据库主从同步，可以减少数据库压力，提高性能。

### 实现方式

- 配置多数据源

	- 数据库和 Application 是有一定侵入性的，如果数据库更换时，application 中的配置文件时需要手动修改的。

- 使用 mysql 的 proxy 中间件代理工具

	- 使用 mysql proxy 固定连接一个数据库，即使数据库地址更换也需要更换项目中的数据库连接配置。

## 高可用

### 基本定义

- 高可用HA（High Available）是分布式架构设计中必须要考虑的因素之一，它通常值，通过设计减少系统不能提供服务的时间。

### 作用

- 读写分离，提高读的处理能力

	- 1.物理服务器增加，负荷增加
	- 2。主从只负责各自的读和写，极大程度的缓解 X 锁 和 S 锁征用
	- 3.从库可配置 myisam 引擎，提升查询性能以节约系统开销
	- 4. 从库同步主库的数据和主库直接写还是有区别的，通过主库发送过来的 binlog 恢复数据，但是，最重要区别在于主库向从库发送 binlog 是异步的，从库恢复数据也是异步的。
	- 5.读写分离适用于读远大于写的场景，如果只有一台服务器，当 select 很多时，update 和 delete 会被这些 select 访问中的数据堵塞，等待 select 结束，并发性能不高。对于写和读比例相近的应用，应该部署多主相互复制。
	- 6.可以在从库启动时增加一些参数来提高其读的性能，例如 —skip-innodb、—skipbdb、—low-priority-updates以及—delay-key-wirte=ALL。当然这些设置也是需要根据具体业务需求来定的，不一定能用上。
	- 7.分摊读写
	- 8.MySQL复制另外一大功能是增加冗余，提高可用性，当一台数据库服务器宕机后能通过调整另外一台从库来以最快的速度恢复服务，因此不能光看性能，也就是说1主1从也是可以的。

- 故障转移，提升 failover 能力

### 高可用解决方案

- MHA

	- 目前在 MySQL 高可用方面是一个相对成熟的解决方案，它由日本 DeNA 公司的 youshimaton（现就职于 Facebook 公司）开发，是一套优秀的作为 MySQL 高可用性环境下故障切换和主从提升的高可用软件。

- MGR

	- MySQL Group Replication 是MySQL官方推出的一种基于Paxos协议的状态机复制。在MGR出现之前，用户常见的MySQL高可用方式，无论怎么变化架构，本质就是Master-Slave架构。MySQL 5.7版本开始支持无损半同步复制（lossless semi-sync replication），从而进一步提示数据复制的强一致性

## 解决方案

### 提高隔离级别

### 使用间隙锁或临键锁

## ShardingSphere-proxy

