# 分库分表

## 数据库拆分

### 业务飞速发展导致了数据规模的急速膨胀，单机数据库已经无法适应互联网业务的发展

### 传统的将数据集中存储至单一数据节点的解决方案，在容量、性能、可用性和运维成本这三方面已经难于满足互联网的海量数据场景。我们在单库单表数据量超过一定容量水位的情况下，索引树层级增加，磁盘 IO 也很可能出现压力，会导致很多问题。

### 从性能方面来说，由于关系型数据库大多采用 B+树类型的索引，在数据量超过阈值的情况下，索引深度的增加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降；同时，高并发访问请求也使得集中式数据库成为系统的最大瓶颈。

### 从可用性的方面来讲，服务化的无状态型，能够达到较小成本的随意扩容，这必然导致系统的最终压力都落在数据库之上。而单一的数据节点，或者简单的主从架构，已经越来越难以承担。从运维成本方面考虑，当一个数据库实例中的数据达到阈值以上，数据备份和恢复的时间成本都将随着数据量的大小而愈发不可控。

## 垂直拆分

### 拆库

- 将一个数据库，拆分成多个提供不同业务数据处理能力的数据库。
- 例如拆分所有订单的数据和产品的数据，变成两个独立的库，这种方式对业务系统有极大的影响，因为数据结构本身发生了变化， SQL  和关联关系也必随之发生了改变。原来一个复杂  SQL直接把一批订单和相关的产品都查了出来，现在这个  SQL  不能用了，得改写  SQL  和程序。先查询订单库数据，拿到这批订单对应的所有产品  id ，再根据产品  id  集合去产品库查询所有的产品信息，最后再业务代码里进行组装。

### 拆表

- 如果单表数据量过大，还可能需要对单表进行拆分。
- 比如一个  200  列的订单主表，拆分成十几个子表：订单表、订单详情表、订单收件信息表、订单支付表、订单产品快照表等等。这个对业务系统的影响有时候可能会大到跟新作一个系统差不多。对于一个高并发的线上生产系统进行改造，就像是给心脑血管做手术，动的愈多，越核心，出现大故障的风险越高。所以，我们一般情况下，尽量少用这种办法。

### 优缺点

- 优点

	- 单库（单表）变小，便于管理和维护
	- 对性能和容量有提升作用
	- 改造后，系统和数据复杂度降低
	- 可以作为微服务改造的基础

- 缺点

	- 库变多，管理变复杂
	- 对业务系统有较强的侵入性
	- 改造过程复杂，容易出故障
	- 拆分到一定程度就无法继续拆分

### 一般做法

- 1.梳理清楚拆分范围和影响范围
- 2.检查评估和重新影响到服务
- 3.准备新的数据库集群复制数据
- 4.修改系统配置并发布新版上线

## 水平拆分

### 按住键分库分表

- 水平拆分就是直接对数据进行分片，有分库和分表两个具体方式，但是都只是降低单个节点数据量，但不改变数据本身的结构。这样对业务系统本身的代码逻辑来说，就不需要做特别大的改动，甚至可以基于一些中间件做到透明。
- 比如把一个  10  亿条记录的订单单库单表（ orderDB 库 库  t_order  表）。我们按照用户  id  除以32  取模，把单库拆分成  32  个库 orderDB_00..31 ；再按订单  id  除以  32  取模，每个库里再拆分成  32  个表 t_order_00..31 。这样一共是  1024  个子表，单个表的数据量就只是  10  万条了。

### 按时间分库分表

- 很多时候，我们的数据是有时间属性的，所以自然可以按照时间维度来拆分。比如当前数据表和历史数据表，甚至按季度，按月，按天来划分不同的表。这样我们按照时间维度来查询数据时，就可以直接定位到当前的这个子表。

### 强制按条件指定分库分表

- 比如配置好某些用户的数据进入单独的库表，其他数据默认处理。

### 自定义方式分库分表

- 指定某些条件的数据进入到某些库或表。

### 优缺点

- 优点

	- 1.解决容量问题
	- 2.比垂直拆分对系统影响小
	- 3.部分提升性能和稳定性

- 缺点

	- 1.集群规模大，管理复杂
	- 2.复杂 SQL 支持问题（业务侵入性、性能）
	- 3.数据迁移问题
	- 4.一致性问题

## 分布式事务

### 定义

- 随着互联网、金融等行业的快速发展，业务越来越复杂，一个完整的业务往往需要调用多个子业务或服务，随着业务的不断增多，涉及的服务及数据也越来越多，越来越复杂。传统的系统难以支撑，出现了应用和数据库等的分布式系统。分布式系统又带来了数据一致性的问题，从而产生了分布式事务。

### 实现分布式下的一致性

- 理想状态

	- 直接像单机数据库事务一样，多个数据库自动通过某种协调机制，实现了跨数据库节点的一致性，

- 一般情况

	- 可以容忍一段时间的数据不一致，最终通过超时终止，调度补偿，等等方式，实现数据的最终状态一致性。

### XA（强一致）

- 基于第一个强一致的思路，就有了基于数据库本身支持的协议，XA分布式事务。XA 整体设计思路可以概括为，如何在现有事务模型上微调扩展，实现分布式事务。

### 柔性事务

- BASE 柔性事务

	- 如果将实现了 ACID 的事务要素的事务称为刚性事务的话，那么基于 BASE 事务要素的事务则称为柔性事务。 BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写

		- 基本可用（Basically Available）保证分布式事务参与方不一定同时在线。
		- 柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够觉察。
		- 而最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性。

- TCC

	- BASE柔性事务TCC
	- TCC模式即将每个服务业务操作分为两个阶段，第一个阶段检查并预留相关资源，第二阶段根据所有服务业务的Try状态来操作，如果都成功，则进行Confirm操作，如果任意一个Try发生错误，则全部Cancel。

		- 准备操作 Try：完成所有业务检查，预留必须的业务资源。
		- 确认操作 Confirm：真正执行的业务逻辑，不做任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务能且只能成功一次。
		-  取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。

- SAGA

	- Saga模式没有try阶段，直接提交事务。
	- 复杂情况下，对回滚操作的设计要求较高。

- AT

	- AT 模式就是两阶段提交，自动生成反向SQL

- 事务特性

	- 原子性（Atomicity）：正常情况下保证。
	- 一致性（Consistency），在某个时间点，会出现A库和B库的数据违反一致性要求的情况，但是最终是一致的。
	- 隔离性（Isolation），在某个时间点，A事务能够读到B事务部分提交的结果
	- 持久性（Durability），和本地事务一样，只要commit则数据被持久。

- 隔离级别

	- 一般情况下都是读已提交（全局锁）、读未提交（无全局锁）。

## 框架和中间件

### Java 框架

- TDDL
- Apaceh ShardingSphere-JDBC

### 中间件

- DRDS（商业闭源）
- Apache ShardingSphere-Proxy
- MyCat/DBLE
- Cobar
- Vitness
- KingShard

