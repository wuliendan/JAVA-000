# 基本概念

并发编程是 Java 程序员最重要的技能之一。

- 并发：一个处理器同时处理多个任务。
- 并行：多个处理器或者是多核的处理器同时处理多个不同的任务。
- 同步：执行某个操作开始后就一直等着按部就班的直到操作结束。
- 异步：执行某个操作后立即离开，后面有响应的话再来通知执行者。

## 临界区

公共资源或者共享数据。

由于共享数据的出现，必然会导致竞争，我们先了解：

- 阻塞：某个操作需要的共享资源被占用了，只能等待，成为阻塞。
- 非阻塞：某个操作需要的共享资源被占用了，不等待立即返回，并携带错误信息回去，期待重试。

如果两个操作都在等待某个共享资源而且都互不退让就会造成死锁：

- 死锁：参考著名的哲学家吃饭问题。
- 饥饿：饥饿的哲学家等不齐筷子吃饭。
- 活锁：相互谦让而导致阻塞无法进入下一步操作，跟死锁相反，死锁是相互竞争而导致的阻塞。

## 共享性

数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免地。最典型地场景是数据库中地数据，为了保证数据的一致性，我们通常需要共享同一个数据库中数据，即使是在主从的情况下，访问的也同一份数据，主从只是为了访问的效率和数据安全，而对于同一份数据做的副本。

## 互斥性

资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。所以我们通常将锁分为共享锁和排它锁，也叫做读锁和写锁。如果资源不具有互斥性，即使是共享资源，我们不需要担心线程安全。例如，对于不可变的是数据共享，所有数据都只能对其进行读操作，所以不用考虑线程安全问题。但是对共享数据的写操作，一般就需要保证互斥性。Java 中提供多种机制来保证互斥性，最简单的方式是使用 Synchronized。